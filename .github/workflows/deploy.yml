name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.AWS_HOST }}
          username: ${{ secrets.AWS_USERNAME }}
          key: ${{ secrets.AWS_SSH_KEY }}
          timeout: 40m
          script: |
            echo "Starting deployment process..."
            
            # Set up working directories
            WORK_DIR="$HOME/fresh_deployment"
            DATA_DIR="$HOME/app_persistent_data"
            
            # Create persistent data directory if it doesn't exist
            mkdir -p "$DATA_DIR/static/images/brand"
            mkdir -p "$DATA_DIR/uploads"
            mkdir -p "$DATA_DIR/data"
            mkdir -p "$DATA_DIR/logs"
            mkdir -p "$DATA_DIR/docker-cache"
            
            # Force proper permissions on data directory
            sudo chown -R $(whoami):$(whoami) "$DATA_DIR"
            chmod -R 777 "$DATA_DIR"
            
            # Clean previous deployment directory
            rm -rf "$WORK_DIR"
            mkdir -p "$WORK_DIR"
            cd "$WORK_DIR"
            
            # Clone repository
            echo "Cloning fresh repository..."
            git clone https://github.com/madushan-jaya-sri/Insta_influ_analyser.git .
            
            if [ ! -d app ]; then
              echo "ERROR: Repository cloning failed or app directory missing!"
              exit 1
            fi
            
            echo "Repository successfully cloned."
            git log -1 --oneline
            
            # Create .env file if it doesn't exist
            if [ ! -f .env ]; then
              echo "Creating .env file..."
              cat > .env << EOF
            FLASK_APP=app
            FLASK_ENV=production
            FLASK_DEBUG=0
            SECRET_KEY=${{ secrets.SECRET_KEY }}
            DATABASE_URL=sqlite:///app.db
            LOG_LEVEL=INFO
            PYTHONUNBUFFERED=1
            APIFY_API_TOKEN=${{ secrets.APIFY_API_TOKEN }}
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
            EOF
            fi
            
            # Create symbolic links for persistent data
            echo "Setting up persistent data links..."
            ln -sf "$DATA_DIR/static" "$WORK_DIR/app/static"
            ln -sf "$DATA_DIR/uploads" "$WORK_DIR/app/uploads"
            ln -sf "$DATA_DIR/data" "$WORK_DIR/app/data"
            ln -sf "$DATA_DIR/logs" "$WORK_DIR/logs"
            
            # Clean up existing containers
            echo "Cleaning up existing containers..."
            docker rm -f instagram-app instagram-nginx fresh_deployment-app-1 || true
            
            # Optimize Docker build - pre-pull the base image
            echo "Pre-pulling base Python image to speed up build..."
            docker pull python:3.10-slim
            
            # Create a modified Dockerfile that explicitly binds to 0.0.0.0
            echo "Creating modified Dockerfile..."
            cp Dockerfile Dockerfile.original
            cat > Dockerfile << EOF
            FROM python:3.10-slim

            # Install Nginx and required packages for wordcloud and other dependencies
            RUN apt-get update && apt-get install -y nginx curl unzip gcc g++ build-essential \\
                python3-dev default-libmysqlclient-dev libpng-dev \\
                libfreetype6-dev pkg-config \\
                && rm -rf /var/lib/apt/lists/*

            # Set working directory
            WORKDIR /app

            # Create necessary directories with proper permissions
            RUN mkdir -p /app/app/static /app/app/uploads /app/app/data
            RUN chmod -R 777 /app/app/static /app/app/uploads /app/app/data

            # Copy requirements first without installing
            COPY requirements.txt /app/

            # Install basic requirements first
            RUN pip install --upgrade pip && \\
                pip install --no-cache-dir gunicorn Flask==2.0.1 Flask-Login==0.5.0 Flask-SQLAlchemy==2.5.1 Werkzeug==2.0.3

            # Install numpy, matplotlib, and other numerical packages first
            RUN pip install --no-cache-dir numpy pandas matplotlib pillow

            # Install wordcloud specifically with all dependencies
            RUN pip install --no-cache-dir wordcloud==1.8.1

            # Install Flask-Migrate for database migrations
            RUN pip install --no-cache-dir Flask-Migrate==3.1.0

            # Now install remaining requirements
            RUN pip install --no-cache-dir --prefer-binary -r requirements.txt

            # Copy application code
            COPY . .

            # Make scripts executable
            RUN if [ -f /app/fix_auth.sh ]; then chmod +x /app/fix_auth.sh; fi
            RUN if [ -f /app/emergency_fix.py ]; then chmod +x /app/emergency_fix.py; fi

            # Create a simple test to verify wordcloud is installed properly
            RUN python -c "import wordcloud; print('Wordcloud installed successfully!')"

            # Expose port
            EXPOSE 8001

            # Command to run the application - hardcoded to bind to 0.0.0.0
            CMD ["gunicorn", "--bind", "0.0.0.0:8001", "--timeout", "120", "--workers", "3", "wsgi:application"]
            EOF
            
            # Update docker-compose.yml to ensure only two containers
            cat > docker-compose.yml << EOF
            version: '3.8'
            
            services:
              app:
                container_name: instagram-app
                build:
                  context: .
                  dockerfile: Dockerfile
                restart: unless-stopped
                environment:
                  - FLASK_APP=app
                  - FLASK_ENV=production
                  - FLASK_DEBUG=0
                  - SECRET_KEY=\${SECRET_KEY}
                  - DATABASE_URL=\${DATABASE_URL:-sqlite:///app.db}
                  - LOG_LEVEL=INFO
                  - PYTHONUNBUFFERED=1
                  - APIFY_API_TOKEN=\${APIFY_API_TOKEN}
                  - OPENAI_API_KEY=\${OPENAI_API_KEY}
                volumes:
                  - ./app/static:/app/app/static
                  - ./app/uploads:/app/app/uploads
                  - ./app/data:/app/app/data
                  - ./logs:/app/logs
                  - $DATA_DIR/docker-cache:/root/.cache/pip
                  - ./app.db:/app/app.db
                networks:
                  - instagram_network
            
              nginx:
                container_name: instagram-nginx
                image: nginx:alpine
                restart: unless-stopped
                ports:
                  - "80:80"
                volumes:
                  - ./nginx.conf:/etc/nginx/conf.d/default.conf
                  - ./app/static:/app/app/static
                  - ./app/uploads:/app/app/uploads
                depends_on:
                  - app
                networks:
                  - instagram_network
            
            networks:
              instagram_network:
                driver: bridge
            EOF
            
            # Update nginx.conf to fix connection issues
            cat > nginx.conf << EOF
            server {
                listen 80;
                server_name localhost;
                
                # Serve static files directly
                location /static/ {
                    alias /app/app/static/;
                    expires 30d;
                    try_files \$uri =404;
                }
                
                location /uploads/ {
                    alias /app/app/uploads/;
                    expires 30d;
                }
                
                # Everything else to Flask app - use service name instead of 127.0.0.1
                location / {
                    proxy_pass http://app:8001;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            }
            EOF
            
            # Create database initialization script
            cat > init_db.py << EOF
            import os
            import sys
            import time
            from flask_migrate import Migrate, upgrade, init, migrate, stamp
            from app import create_app, db
            from app.models.user import User  # Import models to ensure they're registered
            
            def init_database():
                print("Initializing database...")
                app = create_app()
                
                with app.app_context():
                    # Check if migrations directory exists
                    if not os.path.exists('migrations'):
                        print("Initializing migrations...")
                        init()
                    
                    # Create migration for current models
                    print("Creating migration...")
                    migrate(message='initial migration')
                    
                    # Apply migrations
                    print("Applying migrations...")
                    upgrade()
                    
                    # Verify User table exists
                    try:
                        users = User.query.all()
                        print(f"User table exists with {len(users)} users")
                    except Exception as e:
                        print(f"Error verifying User table: {str(e)}")
                        sys.exit(1)
                    
                    print("Database initialization complete!")
            
            if __name__ == '__main__':
                init_database()
            EOF
            
            # Build and start Docker containers
            echo "Building and starting Docker containers..."
            cd "$WORK_DIR"
            
            # Check for Docker Compose
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              COMPOSE_CMD="docker compose"
            fi
            
            # Stop any existing containers
            $COMPOSE_CMD down || true
            
            # Build and start the new containers with increased timeout
            export COMPOSE_HTTP_TIMEOUT=600
            export DOCKER_CLIENT_TIMEOUT=600
            
            # Create empty database file with proper permissions
            touch app.db
            chmod 666 app.db
            
            # Build with retry mechanism
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            until $COMPOSE_CMD build --no-cache || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
              RETRY_COUNT=$((RETRY_COUNT+1))
              echo "Build failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep 5
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "Build failed after $MAX_RETRIES attempts. Exiting."
              exit 1
            fi
            
            # Start containers
            $COMPOSE_CMD up -d
            
            # Give the container time to start
            echo "Waiting for containers to start..."
            sleep 30
            
            # Check container status
            docker ps
            docker logs instagram-app
            
            if docker ps | grep -q "instagram-app" && docker ps | grep -q "instagram-nginx"; then
              echo "Containers are running successfully."
              
              # Copy the database fix script to the container
              echo "Copying database fix script to container..."
              docker cp "$WORK_DIR/fix_database.py" instagram-app:/app/fix_database.py
              docker exec instagram-app chmod +x /app/fix_database.py
              
              # Run the database fix script
              echo "Running database fix script..."
              docker exec instagram-app python /app/fix_database.py
              
              # Fix database permissions
              docker exec instagram-app bash -c 'chmod 666 /app/app.db'
              
              # Verify database initialization
              docker exec instagram-app bash -c 'sqlite3 /app/app.db ".tables"'
              
              echo "Deployment successful with database initialization!"
              echo "To check application logs for errors, run: docker exec instagram-app cat /app/logs/app.log"
            else
              echo "ERROR: Containers failed to start!"
              $COMPOSE_CMD logs
              exit 1
            fi

name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # Updated deployment to use nginx.conf from repository
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.AWS_HOST }}
          username: ${{ secrets.AWS_USERNAME }}
          key: ${{ secrets.AWS_SSH_KEY }}
          script: |
            echo "Starting deployment process..."
            
            # Remove existing directory entirely for a clean start
            rm -rf ~/Insta_influ_analyser
            echo "Removed existing repository directory"
            
            # Fresh clone of the repository
            git clone https://github.com/madushan-jaya-sri/Insta_influ_analyser.git ~/Insta_influ_analyser
            cd ~/Insta_influ_analyser
            echo "Repository freshly cloned"
            
            # Fix indentation error in auth.py
            echo "Fixing indentation error in auth.py..."
            # Create a clean version of the auth.py file
            cat > app/routes/auth.py << 'EOF'
            from flask import (
                Blueprint, render_template, redirect, url_for, request,
                flash, session, current_app
            )
            from flask_login import login_user, logout_user, login_required, current_user
            from werkzeug.urls import url_parse

            # Updated imports for models and forms
            from app.forms import LoginForm, RegistrationForm
            from app.models.user import User
            from app.models.history import History # Import History if needed here, or likely in main.py
            from run import db # Import db instance from run.py

            # Keep the blueprint name, but ensure url_prefix matches run.py if set there
            # The url_prefix='/auth' was added in run.py, so it's correct here.
            auth_bp = Blueprint('auth', __name__)

            @auth_bp.route('/login', methods=['GET', 'POST'])
            def login():
                if current_user.is_authenticated:
                    return redirect(url_for('main.index')) # Redirect to main index or dashboard
                
                form = LoginForm()
                if form.validate_on_submit():
                    # Use SQLAlchemy query to find the user
                    user = db.session.scalar(db.select(User).where(User.username == form.username.data))

                    if user is None or not user.check_password(form.password.data):
                        flash('Invalid username or password', 'danger')
                        return redirect(url_for('auth.login'))

                    # Log the user in using Flask-Login
                    login_user(user, remember=form.remember_me.data)
                    flash(f'Welcome back, {user.username}!', 'success')

                    # Redirect to the page the user was trying to access, or index
                    next_page = request.args.get('next')
                    if not next_page or url_parse(next_page).netloc != '':
                        next_page = url_for('main.index') # Or main.dashboard if that exists
                    return redirect(next_page)
                
                return render_template('auth/login.html', title='Sign In', form=form)

            @auth_bp.route('/register', methods=['GET', 'POST'])
            def register():
                if current_user.is_authenticated:
                    return redirect(url_for('main.index')) # Redirect to main index or dashboard
                
                form = RegistrationForm()
                if form.validate_on_submit():
                    try:
                        user = User(username=form.username.data, email=form.email.data)
                        user.set_password(form.password.data)
                        db.session.add(user)
                        db.session.commit()
                        flash(f'Congratulations, {user.username}, you are now a registered user!', 'success')
                        # Log the user in immediately after registration
                        login_user(user)
                        return redirect(url_for('main.index')) # Redirect to main index or dashboard
                    except Exception as e:
                        db.session.rollback() # Rollback in case of error
                        flash('An error occurred during registration. Please try again.', 'danger')
                        current_app.logger.error(f"Registration error: {str(e)}")
                
                return render_template('auth/register.html', title='Register', form=form)

            @auth_bp.route('/logout')
            @login_required
            def logout():
                logout_user()
                flash('You have been logged out.', 'info')
                return redirect(url_for('main.index'))
            EOF
            
            # Fix ipython version in requirements.txt
            sed -i 's/ipython==9.1.0/ipython==8.18.1/g' requirements.txt
            
            # Create shared volume directories if they don't exist
            mkdir -p ~/app-data/static ~/app-data/uploads ~/app-data/data
            mkdir -p ~/app-data/static/images/brand
            
            # Print git branch and latest commit to verify we're on the correct version
            echo "Current git status:"
            git log -1 --oneline
            
            # Fix static directory structure - merge static directories if needed
            echo "Setting up static directories..."
            if [ -d "./static" ]; then
              echo "Merging ./static into ./app/static"
              mkdir -p ./app/static
              cp -r ./static/* ./app/static/
              rm -rf ./static
              echo "Merged static directories successfully"
            fi
            
            # Create app static directories and ensure brand folder exists
            mkdir -p app/static/images/brand app/static/css
            
            # Debug: Check if logo files exist in the repository
            echo "Checking for logo files in the repository:"
            find . -name "momentro-logo.png" -o -name "momentro_logo.png"
            
            # Copy static files to shared volume
            cp -r app/static/* ~/app-data/static/
            
            # Debug: Verify copied files
            echo "Contents of shared static directory:"
            ls -la ~/app-data/static/images/brand/
            
            # If logo files are missing, copy them from a backup or create a default
            if [ ! -f ~/app-data/static/images/brand/momentro-logo.png ]; then
              echo "Logo file missing! Attempting to find it in the repository..."
              # Find any logo file and copy it to the proper location
              LOGO_FILE=$(find . -name "momentro-logo.png" | head -1)
              if [ -n "$LOGO_FILE" ]; then
                echo "Found logo file at $LOGO_FILE, copying to shared volume"
                cp "$LOGO_FILE" ~/app-data/static/images/brand/momentro-logo.png
                cp "$LOGO_FILE" ~/app-data/static/images/brand/momentro_logo.png
              else
                echo "No logo file found! Creating a placeholder..."
                # Create empty placeholder files to prevent nginx 404 errors
                touch ~/app-data/static/images/brand/momentro-logo.png
                touch ~/app-data/static/images/brand/momentro_logo.png
              fi
            fi
            
            # Remove unnecessary momentro-logo.html if it exists
            rm -f momentro-logo.html
            
            # Ensure static directory has proper permissions
            chmod -R 755 ~/app-data/static
            chmod 666 ~/app-data/static/images/brand/*.png
            
            # Debug: Show static files and permissions
            echo "Checking static files and permissions:"
            ls -la ~/app-data/static/images/brand/
            
            # Clean up unnecessary files from root directory
            echo "Cleaning up unnecessary files from root directory..."
            rm -f *.log *.bak *.tmp
            find . -name "*.pyc" -delete
            find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
            
            # Create WSGI file
            cat > wsgi.py << 'EOF'
            #!/usr/bin/env python3
            import os
            import sys
            
            # Add the current directory to the path
            sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
            
            # Import the create_app function from run.py
            from run import create_app
            
            # Create the application instance
            application = create_app()
            
            # For Gunicorn
            app = application
            
            if __name__ == "__main__":
                app.run()
            EOF
            
            # Create Flask app's Dockerfile
            cat > Dockerfile.app << 'EOF'
            FROM python:3.10-slim

            # Set working directory
            WORKDIR /app

            # Install dependencies
            COPY requirements.txt .
            RUN pip install --upgrade pip && \
                pip install --no-cache-dir gunicorn Flask==2.0.1 Flask-Login==0.5.0 Flask-SQLAlchemy==2.5.1 && \
                pip install --no-cache-dir -r requirements.txt || pip install --no-cache-dir -r requirements.txt --no-deps

            # Copy application code
            COPY . .
            
            # Expose port
            EXPOSE 8000

            # Start Gunicorn
            CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--timeout", "120", "--workers", "3", "--log-level", "info", "wsgi:app"]
            EOF
            
            # Create nginx.conf for the separate nginx container
            cat > docker-nginx.conf << 'EOF'
            server {
                listen 80;
                server_name localhost;
                
                # Debug information location
                location = /debug {
                    add_header Content-Type text/plain;
                    add_header X-Debug-Static "Static files debug page";
                    return 200 "Debug static files";
                }
                
                # Specific locations for exact logo files
                location = /static/images/brand/momentro-logo.png {
                    root /usr/share/nginx/html;
                    add_header Content-Type image/png;
                    expires 30d;
                    access_log on;
                }

                location = /static/images/brand/momentro_logo.png {
                    root /usr/share/nginx/html;
                    add_header Content-Type image/png;
                    expires 30d;
                    access_log on;
                }
                
                # Serve static files directly
                location /static/ {
                    root /usr/share/nginx/html;
                    expires 30d;
                    try_files $uri =404;
                    add_header Cache-Control "public, max-age=31536000";
                }
                
                location /uploads/ {
                    root /usr/share/nginx/html;
                    expires 30d;
                }
                
                # Everything else to Flask app
                location / {
                    proxy_pass http://flask-app:8000;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
            EOF
            
            # Create docker-compose.yml for managing both containers
            cat > docker-compose.yml << 'EOF'
            version: '3'

            services:
              flask-app:
                container_name: instagram-app
                build:
                  context: .
                  dockerfile: Dockerfile.app
                restart: unless-stopped
                environment:
                  - SECRET_KEY=${SECRET_KEY}
                  - APIFY_API_TOKEN=${APIFY_API_TOKEN}
                  - OPENAI_API_KEY=${OPENAI_API_KEY}
                volumes:
                  - ./app-data/static:/app/app/static
                  - ./app-data/uploads:/app/app/uploads
                  - ./app-data/data:/app/app/data
                networks:
                  - app-network

              nginx:
                container_name: instagram-nginx
                image: nginx:alpine
                restart: unless-stopped
                ports:
                  - "80:80"
                volumes:
                  - ./docker-nginx.conf:/etc/nginx/conf.d/default.conf
                  - ./app-data/static:/usr/share/nginx/html/static
                  - ./app-data/uploads:/usr/share/nginx/html/uploads
                depends_on:
                  - flask-app
                networks:
                  - app-network

            networks:
              app-network:
                driver: bridge

            volumes:
              app-data:
                driver: local
            EOF
            
            # Create environment file for docker-compose
            cat > .env << EOF
            SECRET_KEY=${{ secrets.SECRET_KEY }}
            APIFY_API_TOKEN=${{ secrets.APIFY_API_TOKEN }}
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
            EOF
            
            # Stop any running containers
            echo "Stopping existing containers..."
            docker stop instagram-analyzer || true
            docker rm instagram-analyzer || true
            docker stop instagram-app || true
            docker rm instagram-app || true
            docker stop instagram-nginx || true
            docker rm instagram-nginx || true
            
            # Build and start containers using docker-compose
            echo "Building and starting containers with docker-compose..."
            docker-compose up -d --build
            
            # Wait for containers to start
            echo "Waiting for containers to start..."
            sleep 10
            
            # Verify containers are running
            echo "Verifying containers are running..."
            docker ps
            
            # Debug: Check nginx container logs
            echo "Checking nginx container logs..."
            docker logs instagram-nginx
            
            # Debug: Check app container logs
            echo "Checking app container logs..."
            docker logs instagram-app
            
            # Debug: Check nginx configuration
            echo "Checking nginx configuration in container..."
            docker exec instagram-nginx cat /etc/nginx/conf.d/default.conf
            
            # Debug: Check static files in nginx container
            echo "Checking static files in nginx container..."
            docker exec instagram-nginx ls -la /usr/share/nginx/html/static/images/brand/
            
            # Test static file access
            echo "Testing static file access..."
            curl -I http://localhost/static/images/brand/momentro-logo.png
            
            # Try to copy the logo file directly to verify it can be accessed
            echo "Copying logo files directly into nginx container for testing..."
            find . -name "momentro-logo.png" -exec docker cp {} instagram-nginx:/usr/share/nginx/html/static/images/brand/ \;
            
            # Test again
            echo "Testing static file access after direct copy..."
            curl -I http://localhost/static/images/brand/momentro-logo.png
            curl -v http://localhost/static/images/brand/momentro-logo.png
            
            echo "Deployment completed successfully with separate containers." 
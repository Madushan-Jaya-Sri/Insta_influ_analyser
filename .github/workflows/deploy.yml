name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  build_and_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set environment variables
      id: env_vars
      run: |
        # Set environment based on branch/ref
        if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.event.inputs.environment }}" == "production" ]]; then
          echo "ENV=production" >> $GITHUB_ENV
        else
          echo "ENV=staging" >> $GITHUB_ENV
        fi
        
        # Set timestamp for version tracking
        echo "TIMESTAMP=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV
        
    - name: Set up SSH key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.AWS_SSH_KEY }}
        
    - name: Clean up EC2 environment
      env:
        EC2_HOST: ${{ secrets.AWS_HOST }}
        EC2_USER: ${{ secrets.AWS_USERNAME }}
      run: |
        # Create cleanup script
        cat > cleanup_script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== Starting thorough Docker environment cleanup ==="
        
        # Kill any processes that might be using our ports
        echo "Checking for processes using port 80..."
        if sudo lsof -t -i:80 > /dev/null 2>&1; then
          echo "Found processes using port 80, killing them..."
          sudo kill -9 $(sudo lsof -t -i:80)
        else
          echo "No processes found using port 80"
        fi
        
        echo "Checking for processes using port 8000..."
        if sudo lsof -t -i:8000 > /dev/null 2>&1; then
          echo "Found processes using port 8000, killing them..."
          sudo kill -9 $(sudo lsof -t -i:8000)
        else
          echo "No processes found using port 8000"
        fi
        
        # Stop and remove all Docker containers
        echo "Stopping all Docker containers..."
        docker stop $(docker ps -aq) 2>/dev/null || true
        echo "Removing all Docker containers..."
        docker rm -f $(docker ps -aq) 2>/dev/null || true
        
        # Remove specific container names that might exist
        echo "Ensuring specific containers are removed..."
        docker rm -f insta_analyzer_app nginx flask_app 2>/dev/null || true
        
        # Stop system Nginx if running
        echo "Stopping system Nginx service..."
        sudo systemctl stop nginx 2>/dev/null || true
        
        # Remove previous application data
        echo "Removing previous application directories..."
        rm -rf ~/insta_influencer_analyzer
        rm -rf ~/Insta_influ_analyser
        
        # Clean Docker resources
        echo "Pruning Docker networks..."
        docker network prune -f
        
        echo "Pruning Docker volumes..."
        docker volume prune -f
        
        echo "Pruning Docker images..."
        docker image prune -a -f
        
        echo "=== Cleanup completed successfully ==="
        EOF
        
        # Transfer and execute the cleanup script
        chmod +x cleanup_script.sh
        scp -o StrictHostKeyChecking=no cleanup_script.sh $EC2_USER@$EC2_HOST:~/cleanup_script.sh
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "chmod +x ~/cleanup_script.sh && sudo ~/cleanup_script.sh && rm ~/cleanup_script.sh"
        
    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ secrets.AWS_HOST }}
        EC2_USER: ${{ secrets.AWS_USERNAME }}
      run: |
        # Create archive of application code
        tar --exclude="venv" --exclude=".git" --exclude="__pycache__" \
            --exclude="*.pyc" --exclude=".env" --exclude=".env.*" \
            --exclude="*.db" --exclude="app/data/sessions" \
            -czf /tmp/app.tar.gz .
            
        # Transfer application code to EC2
        scp -o StrictHostKeyChecking=no /tmp/app.tar.gz $EC2_USER@$EC2_HOST:/tmp/app.tar.gz
        
        # Create deployment script
        cat > deploy_script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== Starting deployment process ==="
        
        # Create application directory
        echo "Creating application directory..."
        mkdir -p ~/insta_influencer_analyzer
        cd ~/insta_influencer_analyzer
        
        # Extract the application code
        echo "Extracting application code..."
        tar -xzf /tmp/app.tar.gz -C .
        
        # Create .env file for production
        echo "Creating environment file..."
        cat > .env << EOT
        FLASK_ENV=${{ env.ENV }}
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        APIFY_API_TOKEN=${{ secrets.APIFY_API_TOKEN }}
        EOT
        
        # Build and start the application
        echo "Building and starting application with Docker Compose..."
        docker-compose -f docker-compose.prod.yml up -d --build
        
        # Wait for services to start
        echo "Waiting for services to start..."
        sleep 30
        
        # Check if Nginx is running
        echo "Checking Nginx status..."
        docker ps | grep nginx || echo "Nginx container not found"
        
        # Check if web service is running
        echo "Checking web service status..."
        docker ps | grep web || echo "Web container not found"
        
        # Print container logs
        echo "Container logs:"
        docker-compose -f docker-compose.prod.yml logs --tail=50
        
        # Cleanup
        echo "Cleaning up temporary files..."
        rm -f /tmp/app.tar.gz
        
        echo "=== Deployment completed successfully ==="
        EOF
        
        # Transfer and execute the deployment script
        chmod +x deploy_script.sh
        scp -o StrictHostKeyChecking=no deploy_script.sh $EC2_USER@$EC2_HOST:~/deploy_script.sh
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "chmod +x ~/deploy_script.sh && ~/deploy_script.sh && rm ~/deploy_script.sh"

    - name: Verify deployment
      env:
        EC2_HOST: ${{ secrets.AWS_HOST }}
        EC2_USER: ${{ secrets.AWS_USERNAME }}
      run: |
        # Give time for the application to fully start
        sleep 30
        
        echo "=== Container status ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "docker ps -a"
        
        echo "=== Nginx container logs ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "docker logs nginx --tail 50 || echo 'No Nginx logs found'"
        
        echo "=== Web container logs ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "docker logs web --tail 50 || echo 'No web logs found'"
        
        echo "=== Application health check ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "curl -s http://localhost:80 || echo 'Health check failed'"
        
        echo "âœ… Deployment verification complete!"
        echo "Your application should be accessible at: http://${{ secrets.AWS_HOST }}" 
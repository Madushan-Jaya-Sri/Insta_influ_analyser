name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.AWS_HOST }}
          username: ${{ secrets.AWS_USERNAME }}
          key: ${{ secrets.AWS_SSH_KEY }}
          timeout: 40m
          script: |
            echo "Starting deployment process..."
            
            # Set up working directories
            WORK_DIR="$HOME/fresh_deployment"
            DATA_DIR="$HOME/app_persistent_data"
            
            # Create persistent data directory if it doesn't exist
            mkdir -p "$DATA_DIR/static/images/brand"
            mkdir -p "$DATA_DIR/uploads"
            mkdir -p "$DATA_DIR/data"
            mkdir -p "$DATA_DIR/logs"
            mkdir -p "$DATA_DIR/docker-cache"
            
            # Force proper permissions on data directory
            sudo chown -R $(whoami):$(whoami) "$DATA_DIR"
            chmod -R 777 "$DATA_DIR"
            
            # Clean previous deployment directory
            rm -rf "$WORK_DIR"
            mkdir -p "$WORK_DIR"
            cd "$WORK_DIR"
            
            # Clone repository
            echo "Cloning fresh repository..."
            git clone https://github.com/madushan-jaya-sri/Insta_influ_analyser.git .
            
            if [ ! -d app ]; then
              echo "ERROR: Repository cloning failed or app directory missing!"
              exit 1
            fi
            
            echo "Repository successfully cloned."
            git log -1 --oneline
            
            # Create .env file if it doesn't exist
            if [ ! -f .env ]; then
              echo "Creating .env file..."
              cat > .env << EOF
            FLASK_APP=app
            FLASK_ENV=production
            FLASK_DEBUG=0
            SECRET_KEY=${{ secrets.SECRET_KEY }}
            DATABASE_URL=sqlite:///app.db
            LOG_LEVEL=INFO
            PYTHONUNBUFFERED=1
            APIFY_API_TOKEN=${{ secrets.APIFY_API_TOKEN }}
            OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
            EOF
            fi
            
            # Create symbolic links for persistent data
            echo "Setting up persistent data links..."
            ln -sf "$DATA_DIR/static" "$WORK_DIR/app/static"
            ln -sf "$DATA_DIR/uploads" "$WORK_DIR/app/uploads"
            ln -sf "$DATA_DIR/data" "$WORK_DIR/app/data"
            ln -sf "$DATA_DIR/logs" "$WORK_DIR/logs"
            
            # Clean up existing containers
            echo "Cleaning up existing containers..."
            docker rm -f instagram-app instagram-nginx fresh_deployment-app-1 || true
            
            # Optimize Docker build - pre-pull the base image
            echo "Pre-pulling base Python image to speed up build..."
            docker pull python:3.10-slim
            
            # Create a modified Dockerfile that explicitly binds to 0.0.0.0
            echo "Creating modified Dockerfile..."
            cp Dockerfile Dockerfile.original
            cat > Dockerfile << EOF
            FROM python:3.10-slim

            # Install Nginx and required packages for wordcloud and other dependencies
            RUN apt-get update && apt-get install -y nginx curl unzip gcc g++ build-essential \\
                python3-dev default-libmysqlclient-dev libpng-dev \\
                libfreetype6-dev pkg-config \\
                && rm -rf /var/lib/apt/lists/*

            # Set working directory
            WORKDIR /app

            # Create necessary directories with proper permissions
            RUN mkdir -p /app/app/static /app/app/uploads /app/app/data
            RUN chmod -R 777 /app/app/static /app/app/uploads /app/app/data

            # Copy requirements first without installing
            COPY requirements.txt /app/

            # Install basic requirements first
            RUN pip install --upgrade pip && \\
                pip install --no-cache-dir gunicorn Flask==2.0.1 Flask-Login==0.5.0 Flask-SQLAlchemy==2.5.1 Werkzeug==2.0.3

            # Install numpy, matplotlib, and other numerical packages first
            RUN pip install --no-cache-dir numpy pandas matplotlib pillow

            # Install wordcloud specifically with all dependencies
            RUN pip install --no-cache-dir wordcloud==1.8.1

            # Now install remaining requirements
            RUN pip install --no-cache-dir --prefer-binary -r requirements.txt

            # Copy application code
            COPY . .

            # Make scripts executable
            RUN if [ -f /app/fix_auth.sh ]; then chmod +x /app/fix_auth.sh; fi
            RUN if [ -f /app/emergency_fix.py ]; then chmod +x /app/emergency_fix.py; fi

            # Create a simple test to verify wordcloud is installed properly
            RUN python -c "import wordcloud; print('Wordcloud installed successfully!')"

            # Expose port
            EXPOSE 8001

            # Command to run the application - hardcoded to bind to 0.0.0.0
            CMD ["gunicorn", "--bind", "0.0.0.0:8001", "--timeout", "120", "--workers", "3", "wsgi:application"]
            EOF
            
            # Update docker-compose.yml to ensure only two containers
            cat > docker-compose.yml << EOF
            version: '3.8'
            
            services:
              app:
                container_name: instagram-app
                build:
                  context: .
                  dockerfile: Dockerfile
                restart: unless-stopped
                environment:
                  - FLASK_APP=app
                  - FLASK_ENV=production
                  - FLASK_DEBUG=0
                  - SECRET_KEY=\${SECRET_KEY}
                  - DATABASE_URL=\${DATABASE_URL:-sqlite:///app.db}
                  - LOG_LEVEL=INFO
                  - PYTHONUNBUFFERED=1
                  - APIFY_API_TOKEN=\${APIFY_API_TOKEN}
                  - OPENAI_API_KEY=\${OPENAI_API_KEY}
                volumes:
                  - ./app/static:/app/app/static
                  - ./app/uploads:/app/app/uploads
                  - ./app/data:/app/app/data
                  - ./logs:/app/logs
                  - $DATA_DIR/docker-cache:/root/.cache/pip
                networks:
                  - instagram_network
            
              nginx:
                container_name: instagram-nginx
                image: nginx:alpine
                restart: unless-stopped
                ports:
                  - "80:80"
                volumes:
                  - ./nginx.conf:/etc/nginx/conf.d/default.conf
                  - ./app/static:/app/app/static
                  - ./app/uploads:/app/app/uploads
                depends_on:
                  - app
                networks:
                  - instagram_network
            
            networks:
              instagram_network:
                driver: bridge
            EOF
            
            # Update nginx.conf to fix connection issues
            cat > nginx.conf << EOF
            server {
                listen 80;
                server_name localhost;
                
                # Serve static files directly
                location /static/ {
                    alias /app/app/static/;
                    expires 30d;
                    try_files \$uri =404;
                }
                
                location /uploads/ {
                    alias /app/app/uploads/;
                    expires 30d;
                }
                
                # Everything else to Flask app - use service name instead of 127.0.0.1
                location / {
                    proxy_pass http://app:8001;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            }
            EOF
            
            # Build and start Docker containers
            echo "Building and starting Docker containers..."
            cd "$WORK_DIR"
            
            # Check for Docker Compose
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              COMPOSE_CMD="docker compose"
            fi
            
            # Stop any existing containers
            $COMPOSE_CMD down || true
            
            # Build and start the new containers with increased timeout
            export COMPOSE_HTTP_TIMEOUT=600
            export DOCKER_CLIENT_TIMEOUT=600
            
            # Build with retry mechanism
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            until $COMPOSE_CMD build --no-cache || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
              RETRY_COUNT=$((RETRY_COUNT+1))
              echo "Build failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep 5
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "Build failed after $MAX_RETRIES attempts. Exiting."
              exit 1
            fi
            
            # Start containers
            $COMPOSE_CMD up -d
            
            # Give the container time to start
            echo "Waiting for containers to start..."
            sleep 30
            
            # Check container status
            docker ps
            docker logs instagram-app
            docker logs instagram-nginx
            
            if docker ps | grep -q "instagram-app" && docker ps | grep -q "instagram-nginx"; then
              echo "Containers are running successfully."
              
              # Check for any circular import issues and fix them
              echo "Running post-deployment fixes..."
              docker exec instagram-app bash -c 'if [ -f /app/fix_auth.sh ]; then chmod +x /app/fix_auth.sh && /app/fix_auth.sh; fi'
              docker exec instagram-app bash -c 'if [ -f /app/emergency_fix.py ]; then python /app/emergency_fix.py; fi'
              
              # Fix database permissions and run migrations
              echo "Setting up database and permissions..."
              docker exec instagram-app bash -c 'touch /app/app.db && chmod 666 /app/app.db'
              docker exec instagram-app bash -c 'mkdir -p /app/app/data && chmod -R 777 /app/app/data'
              docker exec instagram-app bash -c 'mkdir -p /app/migrations && chmod -R 777 /app/migrations'
              
              # Fix auth.py to properly handle database errors
              echo "Creating database error fix..."
              docker exec instagram-app bash -c "cat > /app/fix_register.py << 'EOF'
import os
import re

# Fix routes/auth.py to handle database errors better
auth_path = '/app/app/routes/auth.py'
if os.path.exists(auth_path):
    with open(auth_path, 'r') as f:
        content = f.read()
    
    # Find the register route
    register_pattern = r'@auth_bp\.route\(\s*[\'\\\"]\/register[\'\\\"]\s*,\s*methods=\[.*\]\s*\)\s*def\s+register\(\):'
    register_match = re.search(register_pattern, content)
    
    if register_match:
        # Get the position of the register function
        pos = register_match.start()
        
        # Check if content already contains error handling fixes
        if 'except Exception as e:' not in content[pos:pos+3000]:
            # Add try-except around the db operations
            insert_pos = content.find('db.session.add(user)', pos)
            if insert_pos > -1:
                modified_content = content[:insert_pos] + 'try:\n        ' + content[insert_pos:]
                
                # Find where to add the except block
                commit_pos = modified_content.find('db.session.commit()', insert_pos)
                if commit_pos > -1:
                    end_pos = modified_content.find('\n', commit_pos + 19)
                    modified_content = modified_content[:end_pos+1] + '    except Exception as e:\n        db.session.rollback()\n        app.logger.error(f\"Registration error: {str(e)}\")\n        return jsonify({\"error\": \"Database error during registration. Please try again.\"}), 500\n' + modified_content[end_pos+1:]
                    
                    with open(auth_path, 'w') as f:
                        f.write(modified_content)
                    print(f'Added error handling to register route in {auth_path}')
                else:
                    print('Could not find db.session.commit() in register route')
            else:
                print('Could not find db.session.add(user) in register route')
        else:
            print('Error handling already exists in register route')
    else:
        print('Could not find register route in auth.py')
else:
    print(f'File not found: {auth_path}')

# Fix models/user.py to ensure unique constraint on email
user_path = '/app/app/models/user.py'
if os.path.exists(user_path):
    with open(user_path, 'r') as f:
        content = f.read()
    
    # Check if unique constraint exists on email
    if 'email = db.Column(db.String' in content and 'unique=True' not in content:
        # Add unique constraint to email field
        email_line_pattern = r'email\s*=\s*db\.Column\(db\.String\(.*\)'
        modified_content = re.sub(email_line_pattern, lambda m: m.group(0)[:-1] + ', unique=True)', content)
        
        with open(user_path, 'w') as f:
            f.write(modified_content)
        print(f'Added unique constraint to email field in {user_path}')
    else:
        print('Email field already has unique constraint or could not be found')
EOF"
              
              # Run the fix script
              docker exec instagram-app bash -c 'python /app/fix_register.py'
              
              # Restart the app container after fixes
              docker restart instagram-app
              sleep 10
              
              # Enable application logging
              echo "Setting up enhanced logging..."
              docker exec instagram-app bash -c "cat > /app/error_logging.py << 'EOF'
import logging
import os
import sys

def setup_logging():
    # Create logs directory if it doesn't exist
    os.makedirs('/app/logs', exist_ok=True)
    
    # Set up file handler for error logging
    file_handler = logging.FileHandler('/app/logs/app.log')
    file_handler.setLevel(logging.ERROR)
    
    # Set up console handler for all logs
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    
    # Set the format for logs
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    # Get the root logger and add handlers
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
    
    return root_logger

# Call setup_logging if this script is run directly
if __name__ == '__main__':
    logger = setup_logging()
    logger.info('Logging configured successfully')
EOF"
              
              # Inject the logging setup into the app initialization
              docker exec instagram-app bash -c "cat > /app/app_init_fix.py << 'EOF'
import os
import re

# Inject logging setup into app/__init__.py
init_path = '/app/app/__init__.py'
if os.path.exists(init_path):
    with open(init_path, 'r') as f:
        content = f.read()
    
    # Check if logging import already exists
    if 'import logging' not in content:
        # Add import at the top
        modified_content = 'import logging\nimport sys\n' + content
        
        # Find create_app function
        create_app_pattern = r'def\s+create_app\(\s*.*\s*\):'
        create_app_match = re.search(create_app_pattern, modified_content)
        
        if create_app_match:
            # Get position after function definition
            pos = create_app_match.end()
            
            # Find the first line after function definition
            next_line_pos = modified_content.find('\n', pos) + 1
            
            # Add logging setup
            logging_setup = '\n    # Set up logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler(\"/app/logs/app.log\")\n        ]\n    )\n    app.logger.setLevel(logging.INFO)\n    app.logger.info(\"Application starting\")\n'
            
            modified_content = modified_content[:next_line_pos] + logging_setup + modified_content[next_line_pos:]
            
            with open(init_path, 'w') as f:
                f.write(modified_content)
            print(f'Added logging setup to {init_path}')
        else:
            print('Could not find create_app function')
    else:
        print('Logging import already exists')
else:
    print(f'File not found: {init_path}')
EOF"
              
              # Run the logging setup script
              docker exec instagram-app bash -c 'python /app/app_init_fix.py'
              
              # Restart the app after all fixes
              docker restart instagram-app
              
              echo "Deployment successful with additional error handling and logging!"
              echo "To check application logs for errors, run: docker exec instagram-app cat /app/logs/app.log"
            else
              echo "ERROR: Containers failed to start!"
              $COMPOSE_CMD logs
              exit 1
            fi

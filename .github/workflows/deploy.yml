name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  build_and_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set environment variables
      id: env_vars
      run: |
        # Set environment based on branch/ref
        if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.event.inputs.environment }}" == "production" ]]; then
          echo "ENV=production" >> $GITHUB_ENV
        else
          echo "ENV=staging" >> $GITHUB_ENV
        fi
        
        # Set timestamp for version tracking
        echo "TIMESTAMP=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV
        
    - name: Set up SSH key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.AWS_SSH_KEY }}
        
    - name: Clean up EC2 environment
      env:
        EC2_HOST: ${{ secrets.AWS_HOST }}
        EC2_USER: ${{ secrets.AWS_USERNAME }}
      run: |
        # Create cleanup script
        cat > cleanup_script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== Starting thorough Docker environment cleanup ==="
        
        # Kill any processes that might be using our ports
        echo "Checking for processes using port 8000..."
        # Use true to ensure command doesn't fail if no process found
        sudo lsof -i :8000 | grep LISTEN || true
        # Kill processes more safely by checking if there are any first
        if sudo lsof -t -i:8000 > /dev/null 2>&1; then
          echo "Found processes using port 8000, killing them..."
          sudo kill -9 $(sudo lsof -t -i:8000)
        else
          echo "No processes found using port 8000"
        fi
        
        echo "Checking for processes using port 80..."
        # Use true to ensure command doesn't fail if no process found
        sudo lsof -i :80 | grep LISTEN || true
        # Kill processes more safely by checking if there are any first
        if sudo lsof -t -i:80 > /dev/null 2>&1; then
          echo "Found processes using port 80, killing them..."
          sudo kill -9 $(sudo lsof -t -i:80)
        else
          echo "No processes found using port 80"
        fi
        
        # Stop existing docker containers
        echo "Stopping all Docker containers..."
        if [ -n "$(docker ps -q)" ]; then
          docker stop $(docker ps -q)
        else
          echo "No running containers to stop"
        fi
        
        # Remove existing docker containers
        echo "Removing all Docker containers..."
        if [ -n "$(docker ps -aq)" ]; then
          docker rm -f $(docker ps -aq)
        else
          echo "No containers to remove"
        fi
        
        # Remove specific container names that might exist
        echo "Ensuring specific containers are removed..."
        docker rm -f insta_analyzer_app nginx flask_app 2>/dev/null || echo "No specific containers to remove"
        
        # Remove nginx at system level
        echo "Stopping system Nginx service..."
        sudo systemctl stop nginx 2>/dev/null || echo "Nginx service not running"
        
        # Remove previous application data
        echo "Removing previous application directories..."
        rm -rf ~/insta_influencer_analyzer
        rm -rf ~/Insta_influ_analyser
        
        # Clean Docker resources
        echo "Pruning Docker networks..."
        docker network prune -f
        
        echo "Pruning Docker volumes..."
        docker volume prune -f
        
        echo "Pruning Docker images..."
        docker image prune -a -f
        
        echo "=== Cleanup completed successfully ==="
        EOF
        
        # Transfer and execute the cleanup script
        chmod +x cleanup_script.sh
        scp -o StrictHostKeyChecking=no cleanup_script.sh $EC2_USER@$EC2_HOST:~/cleanup_script.sh
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "chmod +x ~/cleanup_script.sh && sudo ~/cleanup_script.sh && rm ~/cleanup_script.sh"
        
    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ secrets.AWS_HOST }}
        EC2_USER: ${{ secrets.AWS_USERNAME }}
      run: |
        # Create archive of application code (excluding unnecessary files)
        tar --exclude="venv" --exclude=".git" --exclude="__pycache__" \
            --exclude="*.pyc" --exclude=".env" --exclude=".env.*" \
            --exclude="*.db" --exclude="app/data/sessions" \
            -czf /tmp/app.tar.gz .
            
        # Transfer application code to EC2
        scp -o StrictHostKeyChecking=no /tmp/app.tar.gz $EC2_USER@$EC2_HOST:/tmp/app.tar.gz
        
        # Create deployment script
        cat > deploy_script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== Starting deployment process ==="
        
        # Create application directory
        echo "Creating application directory..."
        mkdir -p ~/insta_influencer_analyzer
        cd ~/insta_influencer_analyzer
        
        # Extract the application code
        echo "Extracting application code..."
        tar -xzf /tmp/app.tar.gz -C .
        
        # Create .env file for production
        echo "Creating environment file..."
        cat > .env << EOT
        FLASK_ENV=${{ env.ENV }}
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        APIFY_API_TOKEN=${{ secrets.APIFY_API_TOKEN }}
        EOT
        
        # Create or update docker-compose file
        echo "Creating Docker Compose configuration..."
        cat > docker-compose.yml << EOT
        version: '3.8'
        
        services:
          app:
            build:
              context: .
              dockerfile: Dockerfile
            container_name: insta_analyzer_app
            restart: always
            ports:
              - "8000:8000"
            volumes:
              - app_data:/app/app/data
              - app_uploads:/app/app/uploads
              - app_static:/app/app/static/images
            env_file:
              - .env
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
              interval: 30s
              timeout: 10s
              retries: 3
        
        volumes:
          app_data:
            driver: local
          app_uploads:
            driver: local
          app_static:
            driver: local
        EOT
        
        # Double-check no containers are running
        echo "Ensuring no containers with same names are running..."
        docker rm -f insta_analyzer_app 2>/dev/null || true
        
        # Build and deploy with docker-compose
        echo "Building and starting application with Docker Compose..."
        docker-compose build --no-cache --progress=plain
        
        # Check if build was successful
        if [ $? -eq 0 ]; then
          echo "Docker build successful, continuing with deployment"
        else
          echo "Docker build failed! Printing detailed logs..."
          docker-compose logs
          exit 1
        fi
        
        # Start the application with detailed logs
        docker-compose up -d
        sleep 10
        
        # Print logs immediately to check for startup errors
        echo "Initial container logs after startup:"
        docker logs insta_analyzer_app
        
        # Cleanup
        echo "Cleaning up temporary files..."
        rm -f /tmp/app.tar.gz
        
        echo "=== Deployment completed successfully ==="
        EOF
        
        # Transfer and execute the deployment script
        chmod +x deploy_script.sh
        scp -o StrictHostKeyChecking=no deploy_script.sh $EC2_USER@$EC2_HOST:~/deploy_script.sh
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "chmod +x ~/deploy_script.sh && ~/deploy_script.sh && rm ~/deploy_script.sh"

    - name: Verify deployment and check logs
      env:
        EC2_HOST: ${{ secrets.AWS_HOST }}
        EC2_USER: ${{ secrets.AWS_USERNAME }}
      run: |
        # Give time for the application to fully start
        sleep 30
        
        echo "=== Container status ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "docker ps -a"
        
        echo "=== Container logs ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "docker logs insta_analyzer_app --tail 50 || echo 'No logs found'"
        
        echo "=== Application health check ==="
        ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "curl -s http://localhost:8000/health || echo 'Health check failed'"
        
        echo "âœ… Deployment verification complete!"
        echo "Your application should be accessible at: http://${{ secrets.AWS_HOST }}:8000" 